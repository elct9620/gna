# Subscriber Schema Specification

Detail document for [SPEC.md](../SPEC.md) §2 Subscriber Management and §6 Subscriber Profile Management.

**Scope:** `subscribers` table definition and token storage strategy for Cloudflare D1 (SQLite).

---

## subscribers Table

| Column                    | Type | Nullable | Default | Description                                             |
| ------------------------- | ---- | -------- | ------- | ------------------------------------------------------- |
| `id`                      | TEXT | No       | —       | Primary key, UUIDv7 format (application-generated)      |
| `email`                   | TEXT | No       | —       | Subscriber email, UNIQUE                                |
| `nickname`                | TEXT | Yes      | NULL    | Display name for personalization                        |
| `unsubscribe_token`       | TEXT | No       | —       | Per-subscriber unsubscribe auth, UNIQUE                 |
| `created_at`              | TEXT | No       | —       | Record creation time (form submission); ISO 8601        |
| `activated_at`            | TEXT | Yes      | NULL    | Double opt-in completion time; NULL = pending           |
| `confirmation_token`      | TEXT | Yes      | NULL    | Email ownership verification (see Unified Confirmation) |
| `confirmation_expires_at` | TEXT | Yes      | NULL    | Confirmation token expiry (24-hour TTL); ISO 8601       |
| `magic_link_token`        | TEXT | Yes      | NULL    | Profile access authentication                           |
| `magic_link_expires_at`   | TEXT | Yes      | NULL    | Magic link expiry (15-minute TTL); ISO 8601             |
| `pending_email`           | TEXT | Yes      | NULL    | New email address awaiting confirmation                 |

### Design Decisions

**Primary Key — UUIDv7 (TEXT):** Application-generated. UUIDv7 embeds a timestamp for natural ordering and does not expose record count. Chosen over email-as-PK because email is mutable (email change flow).

**Token Embedding vs Separate Table:** All tokens have a 1:1 relationship with subscriber. Embedding avoids unnecessary JOINs, appropriate for a lightweight platform.

**Timestamp Format:** D1 (SQLite) stores timestamps as TEXT in ISO 8601 format, generated by the application layer.

**Column Naming:** snake_case for all database columns.

### Unified confirmation_token

`confirmation_token` covers two mutually exclusive scenarios, consistent with SPEC.md Terminology:

> Confirmation token — A temporary token (24-hour lifetime) used to verify email ownership; covers both subscription confirmation (double opt-in) and email change confirmation.

| Scenario                  | Subscriber State                       | Action                                  | Condition                                                |
| ------------------------- | -------------------------------------- | --------------------------------------- | -------------------------------------------------------- |
| Subscription confirmation | pending (`activated_at IS NULL`)       | Set `activated_at` to current timestamp | `activated_at IS NULL`                                   |
| Email change confirmation | activated (`activated_at IS NOT NULL`) | Update `email` to `pending_email` value | `activated_at IS NOT NULL AND pending_email IS NOT NULL` |

The two scenarios are mutually exclusive: a pending subscriber cannot initiate an email change; an activated subscriber does not need subscription confirmation. This replaces the separate `emailConfirmationToken` field in the current entity code.

### created_at vs activated_at

| Column         | Semantics                  | Set When                            | Nullable |
| -------------- | -------------------------- | ----------------------------------- | -------- |
| `created_at`   | Record creation time       | Visitor submits subscription form   | No       |
| `activated_at` | Double opt-in confirmation | Subscriber clicks confirmation link | Yes      |

- `created_at` — present on all subscriber records (pending and activated); standard naming convention
- `activated_at` — only set on activated subscribers; `NULL` means pending
- Status derivation: `activated_at IS NULL` → pending; `activated_at IS NOT NULL` → activated
- The difference between the two can be used for confirmation conversion analysis

---

## Indexes

| Index                                | Columns              | Type   | Purpose                                         |
| ------------------------------------ | -------------------- | ------ | ----------------------------------------------- |
| PRIMARY                              | `id`                 | Unique | Row identity (UUIDv7, TEXT)                     |
| `idx_subscribers_email`              | `email`              | Unique | Email lookup, duplicate prevention              |
| `idx_subscribers_unsubscribe_token`  | `unsubscribe_token`  | Unique | Unsubscribe request authentication              |
| `idx_subscribers_confirmation_token` | `confirmation_token` | —      | Subscription + email change confirmation lookup |
| `idx_subscribers_magic_link_token`   | `magic_link_token`   | —      | Magic link validation                           |

Note: `confirmation_token` and `magic_link_token` indexes are non-unique because NULL values are common (tokens are cleared after use or expiry).

---

## Token Storage Strategy

### Why Embedded Columns

Tokens are stored as columns on the `subscribers` table rather than in a separate tokens table:

- Each token type has a 1:1 relationship with subscriber (at most one active token per type)
- No JOINs needed for token validation — single row lookup
- Consistent with the lightweight, single-table design appropriate for this platform's scale

### TTL Mechanism

D1 has no native TTL support. Token expiration is enforced at two levels:

1. **Application-level validation:** Every token check compares `*_expires_at` against the current time; expired tokens are rejected immediately
2. **Cron Trigger cleanup:** Periodic background job nullifies expired tokens and deletes stale records (see Data Cleanup Rules)

### Token Lifecycle

#### unsubscribe_token

| Event     | Behavior                                                  |
| --------- | --------------------------------------------------------- |
| Created   | Generated when subscriber record is created               |
| Validated | Looked up via `idx_subscribers_unsubscribe_token`         |
| Consumed  | Subscriber record is hard-deleted (token deleted with it) |
| Expires   | Never — persists for the lifetime of the subscriber       |

#### confirmation_token (subscription confirmation)

| Event     | Behavior                                                                                 |
| --------- | ---------------------------------------------------------------------------------------- |
| Created   | Generated on subscribe; set `confirmation_token` + `confirmation_expires_at` (now + 24h) |
| Reissued  | On duplicate pending subscribe: regenerate token + expiry, resend email                  |
| Validated | Look up by token; check `confirmation_expires_at > now`                                  |
| Consumed  | Set `activated_at = now`; clear `confirmation_token` + `confirmation_expires_at`         |
| Expires   | After 24 hours; cleaned up by Cron (entire pending record deleted)                       |

#### confirmation_token (email change)

| Event     | Behavior                                                                                                                       |
| --------- | ------------------------------------------------------------------------------------------------------------------------------ |
| Created   | Generated on profile update with new email; set `confirmation_token` + `confirmation_expires_at` (now + 24h) + `pending_email` |
| Validated | Look up by token; check `confirmation_expires_at > now`; verify `pending_email` not taken                                      |
| Consumed  | Set `email = pending_email`; clear `confirmation_token` + `confirmation_expires_at` + `pending_email`                          |
| Expires   | After 24 hours; Cron clears `confirmation_token` + `confirmation_expires_at` + `pending_email`                                 |

#### magic_link_token

| Event     | Behavior                                                                                        |
| --------- | ----------------------------------------------------------------------------------------------- |
| Created   | Generated on magic link request; set `magic_link_token` + `magic_link_expires_at` (now + 15min) |
| Reissued  | On repeat request: invalidate previous, generate new token + expiry                             |
| Validated | `GET /profile` validates without consuming; check `magic_link_expires_at > now`                 |
| Consumed  | On `POST /api/profile/update`; clear `magic_link_token` + `magic_link_expires_at`               |
| Expires   | After 15 minutes; Cron clears `magic_link_token` + `magic_link_expires_at`                      |

---

## State Transitions & Schema Mapping

State diagram (from SPEC.md):

```
pending ──(confirm)──▶ activated ──(unsubscribe)──▶ deleted
pending ──(token expired + cleanup)──▶ deleted
activated ──(admin remove)──▶ deleted
```

| Transition                    | Column Changes                                                                                                          |
| ----------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| Visitor subscribes            | INSERT: `id`, `email`, `nickname`, `unsubscribe_token`, `created_at`, `confirmation_token`, `confirmation_expires_at`   |
| Pending → Activated           | SET `activated_at = now`; CLEAR `confirmation_token`, `confirmation_expires_at`                                         |
| Activated requests magic link | SET `magic_link_token`, `magic_link_expires_at`                                                                         |
| Profile update (nickname)     | SET `nickname`; CLEAR `magic_link_token`, `magic_link_expires_at`                                                       |
| Profile update (email change) | SET `confirmation_token`, `confirmation_expires_at`, `pending_email`; CLEAR `magic_link_token`, `magic_link_expires_at` |
| Email change confirmed        | SET `email = pending_email`; CLEAR `confirmation_token`, `confirmation_expires_at`, `pending_email`                     |
| Unsubscribe                   | DELETE row                                                                                                              |
| Admin remove                  | DELETE row                                                                                                              |

---

## Data Cleanup Rules

Reference: SPEC.md §Subscriber Data Lifecycle — unsubscribe and cleanup trigger immediate hard deletion; no soft-delete or grace period.

### Cron Trigger Cleanup

| Condition                                                                                            | Action                                                                                        |
| ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| `activated_at IS NULL AND confirmation_expires_at < now`                                             | DELETE row (expired pending subscriber)                                                       |
| `activated_at IS NOT NULL AND confirmation_expires_at IS NOT NULL AND confirmation_expires_at < now` | CLEAR `confirmation_token`, `confirmation_expires_at`, `pending_email` (expired email change) |
| `magic_link_expires_at IS NOT NULL AND magic_link_expires_at < now`                                  | CLEAR `magic_link_token`, `magic_link_expires_at` (expired magic link)                        |

Recommended Cron interval: hourly. Token validation at the application layer provides real-time enforcement; Cron cleanup is for hygiene and data minimization.
